<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Strange Attractors</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <script src="https://unpkg.com/vue@3/dist/vue.global.prod.js"></script>
    <link
      href="https://fonts.googleapis.com/css2?family=Righteous&family=Roboto:wght@300&display=swap"
      rel="stylesheet"
    />
    <script src="/three.min.js"></script>
    <script src="/OrbitControls.min.js"></script>
    <script src="/THREE.MeshLine.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/dat.gui@0.7.9/build/dat.gui.min.js"></script>
    <script src="/namegen.js"></script>
    <script src="/lorenz.build.js"></script>

    <link
      rel="stylesheet"
      href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"
      integrity="sha384-nB0miv6/jRmo5UMMR1wu3Gz6NLsoTkbqJghGIsx//Rlm+ZU03BU6SQNC66uf4l5+"
      crossorigin="anonymous"
    />
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"
      integrity="sha384-7zkQWkzuo3B5mTepMUcHkMB5jZaolc2xDwL6VFqjFALcbeS9Ggm/Yr2r3Dy4lfFg"
      crossorigin="anonymous"
    ></script>
    <script
      defer
      src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js"
      integrity="sha384-43gviWU0YVjaDtb/GhzOouOXtZMP/7XUzwPTstBeZFe/+rCMvRwr4yROQP43s0Xk"
      crossorigin="anonymous"
      onload="renderMathInElement(document.body);"
    ></script>

    <style>
      html,
      body,
      #app,
      #container {
        margin: 0px;
        padding: 0px;
        width: 100%;
        height: 100%;
        overflow: hidden;
      }
      h1,
      h2,
      h3,
      h4,
      h5,
      a {
        text-decoration: none;
        font-family: "Righteous";
        text-transform: uppercase;
      }
      h6,
      label {
        font-family: "Roboto";
        margin: 0px;
      }
      #loading {
        position: absolute;
        left: 40%;
        top: 40%;
        z-index: -1;
        font-size: 60px;
      }
      .black-btn {
        color: white;
        display: inline-block;
        font-size: 12px;
        padding: 0.7em 1.4em;
        margin: 0 0.3em 0.3em 0;
        border-radius: 0.15em;
        box-sizing: border-box;
        font-weight: 400;
        color: #ffffff;
        background-color: #484848;
        box-shadow: inset 0 -0.6em 0 -0.35em rgba(0, 0, 0, 0.17);
        text-align: center;
      }
      .black-btn:active {
        background-color: #989898;
      }
      #randomize {
        position: absolute;
        top: 50px;
        left: 10px;
      }
      #save-attractor {
        position: absolute;
        top: 90px;
        left: 10px;
      }
      #galaxy-name {
        position: absolute;
        top: -10px;
        left: 10px;
        color: white;
      }
      #formula {
        position: absolute;
        width: 260px;
        bottom: 10px;
        right: 30px;
        color: white;
        font-family: "Roboto";
      }
      #formula p {
        margin-block-start: 3px;
        margin-block-end: 3px;
      }
      .span-param {
        font-family: "Roboto";
        font-size: 12px;
        position: relative;
        top: 4px;
        left: 10px;
      }
      #galaxy-params {
        position: absolute;
        bottom: 100px;
        left: 10px;
      }
      #next {
        position: absolute;
        bottom: 20px;
      }
      #blog-link {
        position: absolute;
        top: 10px;
        right: 10px;
        font-family: "Roboto";
        font-size: 10px;
        color: white;
      }
      #param-controls {
        position: absolute;
        display: block;
        color: white;
        bottom: 10px;
        left: 15px;
        width: 280px;
      }
      #param-controls .dg.main {
        width: 100% !important;
      }
    </style>
  </head>
    <body>
    <div id="app">
      <h1 id="loading">LOADING...</h1>
      <h2 id="galaxy-name">{{ galaxyName }}</h2>
      <button id="randomize" type="button" class="black-btn" @click="randomize">
        RANDOMIZE
      </button>
      <button id="save-attractor" class="black-btn" type="button" @click="saveAttractor">
        SAVE
      </button>
      <div id="formula">
        <p>Formula:</p>
        <span
          >\begin{align} \frac{\mathrm{d}x}{\mathrm{d}t} &= \sigma (y - x),
          \\[6pt] \frac{\mathrm{d}y}{\mathrm{d}t} &= x (\rho - z) - y, \\[6pt]
          \frac{\mathrm{d}z}{\mathrm{d}t} &= x y - \beta z. \end{align}</span
        >
      </div>
      <h6 id="galaxy-settings"></h6>
      <div id="param-controls"></div>
      <div id="container" ref="container"></div>
    </div>    <script id="ortho-vs" type="x-shader/x-vertex">
      precision highp float;

      attribute vec3 position;
      attribute vec2 uv;

      uniform mat4 modelViewMatrix;
      uniform mat4 projectionMatrix;

      varying vec2 vUv;

      void main() {
        vUv = uv;
        gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1. );
      }
    </script>

    <script id="shift-fs" type="x-shader/x-fragment">
      precision highp float;

      uniform sampler2D inputTexture;
      uniform vec2 resolution;

      varying vec2 vUv;

      void main(){
        vec2 inc = vec2( 2., 0. ) / resolution;

        float r = texture2D( inputTexture, vUv - inc.xy ).r;
        float g = texture2D( inputTexture, vUv ).g;
        float b = texture2D( inputTexture, vUv + inc.xy ).b;

        vec3 color = vec3( r, g, b );

        gl_FragColor = vec4( color, 1. );
      }
    </script>

            <script>
      "use strict"
      const NUM_POINTS = 20000
      const ANIM_SPEED = 300
      const ANIMATION_FRAMES = NUM_POINTS * ANIM_SPEED
      const SPREAD = 0.8
      const { createApp } = Vue

      let renderer, camera, controls, scene
      let smokeLines, solidLines
      let resolution = new THREE.Vector2(window.innerWidth, window.innerHeight)
      let baseFBO
      let orthoQuad, orthoCamera, orthoScene
      let shiftShader
      let time = 0
      let slowMotion = true
      let gui

      createApp({
        data() {
          return {
            galaxyName: "LORENZ I",
            guiValues: {
              a: 10,
              b: 28,
              c: 2.666666,
              x: 0,
              y: 10,
              z: 10,
            },
            guiControllers: {},
          }
        },
        methods: {
          getAttractor() {
            const a = this.guiValues.a
            const b = this.guiValues.b
            const c = this.guiValues.c
            const x = this.guiValues.x
            const y = this.guiValues.y
            const z = this.guiValues.z
            const color = `0x${Math.abs(Math.floor((a / 20) * 255)).toString(16)}${Math.abs(
              Math.floor((b / 50) * 255)
            ).toString(16)}${Math.abs(Math.floor((c / 5) * 255)).toString(16)}`
            return { a, b, c, x, y, z, color }
          },
          initGui() {
            if (gui) {
              gui.destroy()
            }
            const paramControls = document.getElementById("param-controls")
            paramControls.innerHTML = ""
            gui = new dat.GUI({ autoPlace: false, width: 280 })
            paramControls.appendChild(gui.domElement)
            this.guiControllers = {
              a: gui.add(this.guiValues, "a", 5, 20, 0.000001).name("sigma"),
              b: gui.add(this.guiValues, "b", 5, 50, 0.000001).name("rho"),
              c: gui.add(this.guiValues, "c", 1, 5, 0.000001).name("beta"),
              x: gui.add(this.guiValues, "x", -20, 20, 0.000001).name("x"),
              y: gui.add(this.guiValues, "y", -20, 20, 0.000001).name("y"),
              z: gui.add(this.guiValues, "z", -20, 20, 0.000001).name("z"),
            }
            Object.values(this.guiControllers).forEach((controller) => {
              controller.onChange(() => this.onSliderChange())
            })
            window.__attractorGui = gui
          },
          refreshGui() {
            Object.values(this.guiControllers).forEach((controller) => {
              controller.updateDisplay()
            })
          },
          randomize() {
            this.guiValues.a = Number((Math.random() * 15 + 5).toFixed(6))
            this.guiValues.b = Number((Math.random() * 45 + 5).toFixed(6))
            this.guiValues.c = Number((Math.random() * 4 + 1).toFixed(6))
            this.refreshGui()
            this.onSliderChange()
          },
          async saveAttractor() {
            const attractor = this.getAttractor()
            const payload = {
              attractorName: this.galaxyName,
              a: attractor.a,
              b: attractor.b,
              c: attractor.c,
            }
            try {
              const response = await fetch("/save-attractor", {
                method: "POST",
                headers: {
                  "Content-Type": "application/json",
                },
                body: JSON.stringify(payload),
              })
              if (!response.ok) {
                throw new Error("save failed")
              }
              const result = await response.json()
              alert(`Saved: ${result.fileName}`)
            } catch (error) {
              alert("Failed to save attractor.")
            }
          },
          createRenderTarget() {
            return new THREE.WebGLRenderTarget(1, 1, {
              wrapS: THREE.ClampToEdgeWrapping,
              wrapT: THREE.ClampToEdgeWrapping,
              format: THREE.RGBAFormat,
              stencilBuffer: false,
              depthBuffer: true,
            })
          },
          initScene() {
            const attractor = this.getAttractor()
            lorenz.init(
              attractor.a,
              attractor.c,
              attractor.b,
              attractor.x,
              attractor.y,
              attractor.z
            )
            scene.remove(scene.getObjectByName("att"))
            const attractorObject = new THREE.Object3D()
            attractorObject.name = "att"
            scene.add(attractorObject)
            time = 0
            lorenz.next(NUM_POINTS)
            let geometry = new THREE.Geometry()
            lorenz
              .points(true, THREE.Vector3)
              .forEach((point) => geometry.vertices.push(point))
            geometry.computeBoundingBox()
            const center = geometry.boundingBox.max.clone()
            center.sub(geometry.boundingBox.min)
            center.multiplyScalar(0.5)
            center.add(geometry.boundingBox.min)
            center.multiplyScalar(-1)
            attractorObject.position.copy(center)
            const line = new THREE.MeshLine()
            line.setGeometry(geometry, (p) => {
              return 2 + Math.sin(500 * p)
            })
            smokeLines = new THREE.Mesh(
              line.geometry,
              new THREE.MeshLineMaterial({
                color: new THREE.Color(Number(attractor.color)),
                resolution: resolution,
                sizeAttenuation: true,
                lineWidth: 1.5 * SPREAD,
                opacity: 0.05,
                near: camera.near,
                far: camera.far,
                depthWrite: false,
                depthTest: false,
                transparent: true,
                blending: THREE.AdditiveBlending,
              })
            )
            attractorObject.add(smokeLines)
            geometry = new THREE.BufferGeometry()
            const positions = new Float32Array(lorenz.points())
            geometry.addAttribute("position", new THREE.BufferAttribute(positions, 3))
            solidLines = new THREE.Line(
              geometry,
              new THREE.LineBasicMaterial({
                color: new THREE.Color(0xffffff),
                opacity: 0.25,
                transparent: true,
                blending: THREE.AdditiveBlending,
              })
            )
            attractorObject.add(solidLines)
            this.galaxyName = namegen()
          },
          onSliderChange() {
            if (!scene) return
            slowMotion = false
            this.initScene()
          },
          initThree() {
            const container = this.$refs.container
            scene = new THREE.Scene()
            camera = new THREE.PerspectiveCamera(80, window.innerWidth / window.innerHeight, 0.1, 10000)
            camera.target = new THREE.Vector3(0, 0, 0)
            camera.position.set(0, 0, 50)
            camera.lookAt(camera.target)
            scene.add(camera)
            const starGeo = new THREE.Geometry()
            for (let i = 0; i < 3000; i++) {
              const star = new THREE.Vector3(
                Math.random() * 10000 - 5000,
                Math.random() * 10000 - 5000,
                Math.random() * 10000 - 5000
              )
              starGeo.vertices.push(star)
            }
            const sprite = new THREE.TextureLoader().load("./circle.png")
            const starMaterial = new THREE.PointsMaterial({
              color: 0xaaaaaa,
              size: 10,
              blending: THREE.AdditiveBlending,
              transparent: true,
              depthTest: false,
              sizeAttenuation: true,
              map: sprite,
            })
            const stars = new THREE.Points(starGeo, starMaterial)
            scene.add(stars)
            renderer = new THREE.WebGLRenderer({
              antialias: true,
              preserveDrawingBuffer: false,
            })
            renderer.setPixelRatio(window.devicePixelRatio)
            renderer.setClearColor(0x261b1f, 1)
            container.appendChild(renderer.domElement)
            renderer.shadowMap.enabled = true
            renderer.shadowMap.type = THREE.PCFShadowMap
            controls = new THREE.OrbitControls(camera, renderer.domElement)
            controls.enableDamping = true
            controls.dampingFactor = 0.1
            controls.rotateSpeed = 0.1
            baseFBO = this.createRenderTarget()
            shiftShader = new THREE.RawShaderMaterial({
              uniforms: {
                inputTexture: { type: "t", value: baseFBO.texture },
                resolution: { type: "v2", value: resolution },
              },
              vertexShader: document.getElementById("ortho-vs").textContent,
              fragmentShader: document.getElementById("shift-fs").textContent,
            })
            orthoScene = new THREE.Scene()
            orthoCamera = new THREE.OrthographicCamera(1 / -2, 1 / 2, 1 / 2, 1 / -2, 0.00001, 1000)
            orthoQuad = new THREE.Mesh(new THREE.PlaneBufferGeometry(1, 1))
            orthoScene.add(orthoQuad)
            this.onWindowResized()
            this.initScene()
            this.animate()
          },
          onWindowResized() {
            if (!renderer) return
            const container = this.$refs.container
            const w = container.clientWidth
            const h = container.clientHeight
            renderer.setSize(w, h)
            camera.aspect = w / h
            camera.updateProjectionMatrix()
            const dPR = window.devicePixelRatio
            resolution.set(w * dPR, h * dPR)
            baseFBO.setSize(w * dPR, h * dPR)
            orthoQuad.scale.set(w, h, 1)
            orthoCamera.left = -w / 2
            orthoCamera.right = w / 2
            orthoCamera.top = h / 2
            orthoCamera.bottom = -h / 2
            orthoCamera.updateProjectionMatrix()
          },
          animate() {
            requestAnimationFrame(this.animate)
            controls.update()
            if (slowMotion === true) {
              solidLines.geometry.setDrawRange(0, time)
              smokeLines.geometry.setDrawRange(0, time)
              if (time < ANIMATION_FRAMES) time += 300
            }
            renderer.render(scene, camera, baseFBO)
            orthoQuad.material = shiftShader
            renderer.render(orthoScene, orthoCamera)
          },
        },
        mounted() {
          this.animate = this.animate.bind(this)
          this.onResize = this.onWindowResized.bind(this)
          this.initGui()
          this.initThree()
          window.addEventListener("resize", this.onResize)
        },
        beforeUnmount() {
          window.removeEventListener("resize", this.onResize)
          if (gui) {
            gui.destroy()
          }
        },
      }).mount("#app")
    </script>
    <!-- Cloudflare Web Analytics -->
    <script
      defer
      src="https://static.cloudflareinsights.com/beacon.min.js"
      data-cf-beacon='{"token": "0000e1cd845143ab9f875c9c21658a85"}'
    ></script>
    <!-- End Cloudflare Web Analytics -->
  </body>
</html>



